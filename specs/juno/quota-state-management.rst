Juno > Nova > Implementing state management for quotas
Thu, May 15th @ 1:30pm 

==========================================
Quota state management
==========================================

Blueprint is here: 
https://blueprints.launchpad.net/nova/+spec/quota-state-management

Spec is here: https://review.openstack.org/#/c/93353/

Enhance Nova quotas by adding a concept of state management to quotas. Making 
it easier to align existing business processes with OpenStack.

Problem description
===================
Some private cloud operators depend on quota to not only control the rate at
which their tenants consume their cloud, but also track how much of their
cloud has been allocated. Unfortunately the operator has no visibility into
how often a tenant has requested their quota be increased, or if there are
any quota increase requests in the pipe. At the moment nova quota allocations
cannot be tracked on a discrete basis. When one looks at the quota for a given
tenant they will only see what is currently available to that tenant, without
any history associated with that.

When one of our private cloud tenants wants to increase their quota
they’ll need to file a request. That request will be compared against
projected cluster capacity as well as certain financial models. If the request 
falls within certain parameters it’ll need larger finance approval before the
quota can be allocated. During this process there is no visibility to either
operators,finance partners, or capacity planning teams who may need to view
the overall capacity of a given cluster. In an enterprise each request could
change hands many times. There will be race conditions when multiple tenants
request capacity at the same time. We need a way to request, review, approve,
and deny quota enhancement requests within OpenStack.

Some quota allocations are granted on a temporary basis. Say during a traffic
spike you want to increase quota for a given tenant, but take it away after a
predetermined period of time. For that we need a concept of leasing quotas.


Proposed change
===============

Implement state management and leasing in quotas. Tenant quota will be no
longer be a single row per tenant, per resource, but instead per-tenant,
per-resource, per-request. A tenants available quota will now be the sum of
their active quotas.
This means that there is now a concept of "soft" vs "hard" quota. Soft quota
will be the sum of all quota requests from a given project excluding those
that have been deleted. Hard quota will represent only the quota that has been
marked as active.
Additionally each quota can have an optional expiry applied to it. Once expiry
has passed that quota should be marked as disabled in the DB.


Alternatives
------------
Public and private providers could continue to manage this quota state outside
of openstack. This would result in significant duplication of effort. Bringing
this simple concept in to OpenStack would make it much easier to integrate into
enterprise. 

Data model impact
-----------------

A new model will be created called "quota_state" with the following elements:

* id (autoinc)
* 'state' Varchar(32), Unique, Not NULL. Contains the name of the state. "New,
  In-Review, Denied, Approved, Expired" etc
* 'created_at' datetime, Not NULL
* 'modified_at' datetime, auto(now)

A new model will be created called "quota_requests" whose purpose is to track
requests and associate metadata to it. 

* 'UUID' (varchar, unique) autogenerated UUID
* 'Active' (boolean) to indicate whether or not the row should be used to
  calculate a Project's total available quota.
* 'State' (FKC to quota_state.id)
* 'external_ref' medium text field for a json blob to associate arbitrary 
  external reference key/value pairs.
  eg: ``{
  "original_request":"http://someurl.com/bug.cgi/ref=12345",
  "capacity_approval":"http://some-site.com/blah.cgi?foo=12345"
  }``
* 'created_at' (datetime)
* 'updated_at' (datetime, auto(now)
* 'deleted_at' (datetime,default=NULL)
* 'expires_at' (datetime, default=NULL) the date on which the given quota 
  should no longer be considered valid. A null value indicates the 
  quota will never expire.

A new model will be created called "quota_request_history"

* 'UUID' (FKC to quota_requests.UUID)
* 'time' (Datetime, auto(now))
* 'user_id' (varchar) UUID of user making the change.
* 'state_change' (FKC to the quota_states table) the new state of the quota
  request
* 'log' (varchar(255)) any log data from the user who made the change.

Add 2 elements to the quota model:

* 'request_id' (FKC to requests.UUID) 
* 'Active' (boolean) to indicate whether or not the row should be used to
  calculate a Project's total available quota. # This would be duplication of
  the same column in the quota_requests table. Done purely to make quota
  selections lest compute intensive.




REST API impact
---------------

Note: My knowledge of the Nova API schema is lacking. So i'm going to have to
be a bit vague here. Help?

* os-quota-show-requests

  * GET
  * For admin users, return a list of all quota requests under their domain.
    (There will be limitations based on the outcome of the tenancy design
    sessions. I don't want to address that here)
  * For non-admin users: return a list of all quota elements for their project.
  * Optionally allow a comma separated list of states and only return rows 
    matching those states
    
* os-quota-create

  * POST
  * Create a new quota request in the quota_requests table.
  * Required parameters:
  
    * a json blob containing at least one resource=>value setting.
      These will be parsed into the quotas table.
    * log, text string containing any log information to store in the
      quota_requests_history table

  * Optional parameters:

    * external_ref, json blob of a reference to an external tracking mechanism
      as defined in the quota_requests model, above.

      
* os-quota-state-update

  * POST
  * Update an existing quota request.
    * Users can cancel their own request, or modify the resource quantities
    within it as long as the request is not 'active'
    * Admins can change the state of the request regardless of the state. 

  * Required parameters
  
    * log, text string containing any log information to store in the
      quota_requests_history table
    * request_id, UUID of the request
    * State, the state you'd like the request moved to. Use the same state for
      no change

  * Optional parameters
    * external_ref, json blob of a reference to an external tracking mechanism.

    
    
    
    
    

* os-quota-sets

  * enhance this method to return a list of all quota requests, as well as thei
    list of soft vs hard quota.
  * A description of what the method does suitable for use in user i
    documentation


limits
* This method should be modified to return a dict of the sum of the "soft" 
limits in the json blob as well as the "absolute" limits.

absolute-limits
* Add a flag to allow returning the sum of the json blob for all tenants, 
rather than just a specified tenant.

Security impact
---------------

Displaying absolute limits for all tenants should be locked down to just the 
admin user, or another arbitrary role type (capacity_admin). Many companies 
would consider the size of their private cloud, allocated quota, and used 
capacity to be proprietery information and would not want that shared.
Further concern, if you have a very large number of tenants, quotas, and quota
requests this method could require significant database time to select, sum, 
and return those lines. An attacker could use this as a resource exhaustion
DoS.

Notifications impact
--------------------

Other end user impact
---------------------

python-novaclient will need to be extended to include the --all-tenants flag 
for the absolute-limits method.

the json blob returned by absolute-limits will include "soft" limits, which
will be a deviation from the way it returns now.

when allocating quota the cloud admin will need to supply an additional flag to
mark the state of quota as "approved".

Performance Impact
------------------

Calculating quota by summing rows is going to require additional CPU on the DB
This would only be significant in large or 'mega' scale environments. This can
be mitigated in those environments by only calling quota-get against Read-only
DB slaves. 

Other deployer impact
---------------------
By default this wont make any changes to how quotas are allocated. But there
will be additional hooks to allow operators to take advantage of this. By
default creating quotas will be 'hard' quota. 

Developer impact
----------------

* Any API changes will need to be reflected in the nova CLI
* Anything that queries quota in nova without using Oslo would be in a bad state.


Implementation
==============

Assignee(s)
-----------

Primary assignee:
  penick@yahoo-inc.com

Other contributors:
 openstack-dev@yahoo-inc.com,
 Anyone else who wants to help out. 

Work Items
----------

* Gain consensus on the blueprint 
* Write the code :)


Dependencies
============



Testing
=======



Documentation Impact
====================

There will be moderate impact to documentation to track not only the CLI 
changes mentioned above, but also the best practices for integrating quota
management with enterprise processes.


References
==========

Please add any useful references here. You are not required to have any
reference. Moreover, this specification should still make sense when your
references are unavailable. Examples of what you could include are:

* Links to mailing list or IRC discussions

* Links to notes from a summit session

* Links to relevant research, if appropriate

* Related specifications as appropriate (e.g.  if it's an EC2 thing, link the
  EC2 docs)

* Anything else you feel it is worthwhile to refer to
